/*! behaviors.js is part of Webrecorder project. Copyright (C) 2021, Webrecorder Software. Licensed under the Affero General Public License v3. */(()=>{"use strict";var __webpack_modules__={"./src/autofetcher.js":
/*!****************************!*\
  !*** ./src/autofetcher.js ***!
  \****************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "AutoFetcher": () => (/* binding */ AutoFetcher)\n/* harmony export */ });\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/utils */ "./src/lib/utils.js");\n// AutoFetcher script\n// extract and fetch all urls from srcsets, from images as well as audio/video\n// also extract any urls from media query stylesheets that have not necessarily been loaded\n// (May not work for cross-origin stylesheets)\n\n\n\nconst SRC_SET_SELECTOR = "img[srcset], img[data-srcset], img[data-src], " +  \n"video[srcset], video[data-srcset], video[data-src], audio[srcset], audio[data-srcset], audio[data-src], " +\n"picture > source[srcset], picture > source[data-srcset], picture > source[data-src], " +\n"video > source[srcset], video > source[data-srcset], video > source[data-src], " +\n"audio > source[srcset], audio > source[data-srcset], audio > source[data-src]";\n\nconst SRCSET_REGEX = /\\s*(\\S*\\s+[\\d.]+[wx]),|(?:\\s*,(?:\\s+|(?=https?:)))/;\n\nconst STYLE_REGEX = /(url\\s*\\(\\s*[\\\\"\']*)([^)\'"]+)([\\\\"\']*\\s*\\))/gi;\nconst IMPORT_REGEX = /(@import\\s*[\\\\"\']*)([^)\'";]+)([\\\\"\']*\\s*;?)/gi;\n\n\n// ===========================================================================\nclass AutoFetcher\n{\n  constructor() {\n    this.urlSet = new Set();\n    this.urlqueue = [];\n    this.numPending = 0;\n    this.start();\n  }\n\n  async start() {\n    await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.awaitLoad)();\n    this.run();\n    this.initObserver();\n  }\n\n  done() {\n    //TODO:\n    return Promise.resolve();\n  }\n\n  async run() {\n    this.extractSrcSrcSetAll(document);\n    this.extractStyleSheets();\n  }\n\n  isValidUrl(url) {\n    return url && (url.startsWith("http:") || url.startsWith("https:"));\n  }\n\n  queueUrl(url) {\n    try {\n      url = new URL(url, document.baseURI).href;\n    } catch (e) {\n      return;\n    }\n\n    if (!this.isValidUrl(url)) {\n      return;\n    }\n\n    if (this.urlSet.has(url)) {\n      return;\n    }\n\n    this.urlSet.add(url);\n\n    this.doFetch(url);\n  }\n\n  async doFetch(url) {\n    this.urlqueue.push(url);\n    if (this.numPending <= 6) {\n      while (this.urlqueue.length > 0) {\n        const url = this.urlqueue.shift();\n        try {\n          this.numPending++;\n          (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.behavior_log)("AutoFetching: " + url);\n          const resp = await fetch(url);\n          await resp.blob();\n        } catch (e) {\n          (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.behavior_log)(e);\n        }\n        this.numPending--;\n      }\n    }\n  }\n\n  initObserver() {\n    this.mutobz = new MutationObserver((changes) => this.observeChange(changes));\n\n    this.mutobz.observe(document.documentElement, {\n      characterData: false,\n      characterDataOldValue: false,\n      attributes: true,\n      attributeOldValue: true,\n      subtree: true,\n      childList: true,\n      attributeFilter: ["srcset"]\n    });\n  }\n\n  processChangedNode(target) {\n    switch (target.nodeType) {\n    case Node.ATTRIBUTE_NODE:\n      if (target.nodeName === "srcset") {\n        this.extractSrcSetAttr(target.nodeValue);\n      }\n      break;\n\n    case Node.TEXT_NODE:\n      if (target.parentNode && target.parentNode.tagName === "STYLE") {\n        this.extractStyleText(target.nodeValue);\n      }\n      break;\n\n    case Node.ELEMENT_NODE:\n      if (target.sheet) {\n        this.extractStyleSheet(target.sheet);\n      }\n      this.extractSrcSrcSet(target);\n      setTimeout(() => this.extractSrcSrcSetAll(target), 1000);\n      break;\n    }\n  }\n\n  observeChange(changes) {\n    for (const change of changes) {\n      this.processChangedNode(change.target);\n\n      if (change.type === "childList") {\n        for (const node of change.addedNodes) {\n          this.processChangedNode(node);\n        }\n      }\n    }\n  }\n\n  extractSrcSrcSetAll(root) {\n    const elems = root.querySelectorAll(SRC_SET_SELECTOR);\n\n    for (const elem of elems) {\n      this.extractSrcSrcSet(elem);\n    } \n  }\n\n  extractSrcSrcSet(elem) {\n    if (!elem || elem.nodeType !== Node.ELEMENT_NODE) {\n      console.warn("No elem to extract from");\n      return;\n    }\n\n    const src = elem.src || elem.getAttribute("data-src");\n\n    if (src) {\n      this.queueUrl(src);\n    }\n\n    const srcset = elem.srcset || elem.getAttribute("data-srcset");\n\n    if (srcset) {\n      this.extractSrcSetAttr(srcset);\n    }\n  }\n\n  extractSrcSetAttr(srcset) {\n    for (const v of srcset.split(SRCSET_REGEX)) {\n      if (v) {\n        const parts = v.trim().split(" ");\n        this.queueUrl(parts[0]);\n      }\n    }\n  }\n\n  extractStyleSheets(root) {\n    root = root || document;\n\n    for (const sheet of root.styleSheets) {\n      this.extractStyleSheet(sheet);\n    }\n  }\n\n  extractStyleSheet(sheet) {\n    let rules;\n    \n    try {\n      rules = sheet.cssRules || sheet.rules;\n    } catch (e) {\n      (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.behavior_log)("Can\'t access stylesheet");\n      return;\n    }\n\n    for (const rule of rules) {\n      if (rule.type === CSSRule.MEDIA_RULE) {\n        this.extractStyleText(rule.cssText);\n      }\n    }\n  }\n\n  extractStyleText(text) {\n    const urlExtractor = (m, n1, n2, n3) => {\n      this.queueUrl(n2);\n      return n1 + n2 + n3;\n    };\n\n    text.replace(STYLE_REGEX, urlExtractor).replace(IMPORT_REGEX, urlExtractor);\n  }\n}\n\n\n\n//# sourceURL=webpack://browsertrix-behaviors/./src/autofetcher.js?')},"./src/autoplay.js":
/*!*************************!*\
  !*** ./src/autoplay.js ***!
  \*************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Autoplay": () => (/* binding */ Autoplay)\n/* harmony export */ });\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/utils */ "./src/lib/utils.js");\n\n\n\n// const domainSpecificRedirect = [\n//   {\n//     rx: [/w\\.soundcloud\\.com/],\n//     async handle(url) {\n//       if (url.searchParams.get("auto_play") === "true") {\n//         return null;\n//       }\n\n//       url.searchParams.set("auto_play", "true");\n//       // set continuous_play to true in order to handle\n//       // a playlist etc\n//       url.searchParams.set("continuous_play", "true");\n//       return url.href;\n//     },\n//   },\n//   {\n//     rx: [/player\\.vimeo\\.com/],\n//     async handle(url) {\n//       const video = document.querySelector("video");\n\n//       if (video) {\n//         video.play();\n//         behavior_log("play video");\n//       }\n//     }\n//   },\n//   {\n//     rx: [/youtube(?:-nocookie)?\\.com\\/embed\\//],\n//     async handle(url) {\n//       const center = document.elementFromPoint(\n//         document.documentElement.clientWidth / 2,\n//         document.documentElement.clientHeight / 2);\n      \n//       if (center) {\n//         center.click();\n//         behavior_log("play video");\n//         await sleep(1000);\n//       }\n//     },\n//   },\n// ];\n\n\n// ===========================================================================\nclass Autoplay {\n  constructor() {\n    this.mediaSet = new Set();\n\n    this.promises = [];\n\n    this.promises.push(new Promise((resolve) => this._initDone = resolve));\n\n    this.start();\n  }\n\n  // async checkAutoPlayRedirect() {\n  //   await sleep(500);\n\n  //   const url = new URL(self.location.href);\n\n  //   for (const ds of domainSpecificRedirect) {\n  //     for (const rx of ds.rx) {\n  //       if (url.href.search(rx) >= 0) {\n  //         await ds.handle(url);\n  //       }\n  //     }\n  //   }\n  // }\n\n  async start() {\n    await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.awaitLoad)();\n    this.initObserver();\n    //await this.checkAutoPlayRedirect();\n\n    for (const [inx, elem] of document.querySelectorAll("video, audio").entries()) {\n      this.addMediaWait(elem);\n    }\n\n    await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.sleep)(1000);\n\n    this._initDone();\n  }\n\n  initObserver() {\n    this.mutobz = new MutationObserver((changes) => this.observeChange(changes));\n\n    this.mutobz.observe(document.documentElement, {\n      characterData: false,\n      characterDataOldValue: false,\n      attributes: false,\n      attributeOldValue: false,\n      subtree: true,\n      childList: true,\n    });\n  }\n\n  observeChange(changes) {\n    for (const change of changes) {\n      if (change.type === "childList") {\n        for (const node of change.addedNodes) {\n          if (node instanceof HTMLMediaElement) {\n            this.addMediaWait(node);\n          }\n        }\n      }\n    }\n  }\n\n  addMediaWait(media) {\n    (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.behavior_log)("media: " + media.outerHTML);\n    if (media.src && media.src.startsWith("http:") || media.src.startsWith("https:")) {\n      if (!this.mediaSet.has(media.src)) {\n        (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.behavior_log)("fetch media URL: " + media.src);\n        this.mediaSet.add(media.src);\n        this.promises.push(fetch(media.src).then(resp => resp.blob()));\n        return;\n      }\n    }\n    if (media.play) {\n      let resolve;\n\n      const p = new Promise((res) => {\n        resolve = res;\n      });\n\n      this.promises.push(p);\n\n      media.addEventListener("loadstart", () => (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.behavior_log)("loadstart"));\n      media.addEventListener("loadeddata", () => (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.behavior_log)("loadeddata"));\n      media.addEventListener("playing", () => { (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.behavior_log)("playing"); resolve() });\n      media.addEventListener("ended", () => { (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.behavior_log)("ended"); resolve() });\n      media.addEventListener("paused", () => { (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.behavior_log)("paused"); resolve() });\n      media.addEventListener("error", () => { (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.behavior_log)("error"); resolve() });\n\n      if (media.paused) {\n        (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.behavior_log)("generic play event for: " + media.outerHTML);\n        media.muted = true;\n        media.click();\n        media.play();\n      }\n    }\n  }\n\n  done() {\n    return Promise.allSettled(this.promises);\n  }\n}\n\n\n\n//# sourceURL=webpack://browsertrix-behaviors/./src/autoplay.js?')},"./src/autoscroll.js":
/*!***************************!*\
  !*** ./src/autoscroll.js ***!
  \***************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "AutoScroll": () => (/* binding */ AutoScroll)\n/* harmony export */ });\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/utils */ "./src/lib/utils.js");\n\n\n\n// ===========================================================================\nclass AutoScroll extends _lib_utils__WEBPACK_IMPORTED_MODULE_0__.Behavior\n{\n  static get name() {\n    return "Autoscroll";\n  }\n\n  async* [Symbol.asyncIterator]() {\n    const canScrollMore = () =>\n      self.scrollY + self.innerHeight <\n      Math.max(\n        self.document.body.scrollHeight,\n        self.document.body.offsetHeight,\n        self.document.documentElement.clientHeight,\n        self.document.documentElement.scrollHeight,\n        self.document.documentElement.offsetHeight\n      );\n\n    const scrollOpts = { top: 250, left: 0, behavior: "auto" };\n\n    while (canScrollMore()) {\n      self.scrollBy(scrollOpts);\n      yield {"msg": "Scrolling by " + scrollOpts.top};\n      await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.sleep)(500);\n    }\n  }\n}\n\n\n//# sourceURL=webpack://browsertrix-behaviors/./src/autoscroll.js?')},"./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "BehaviorManager": () => (/* binding */ BehaviorManager)\n/* harmony export */ });\n/* harmony import */ var _autofetcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./autofetcher */ "./src/autofetcher.js");\n/* harmony import */ var _autoplay__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./autoplay */ "./src/autoplay.js");\n/* harmony import */ var _autoscroll__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./autoscroll */ "./src/autoscroll.js");\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/utils */ "./src/lib/utils.js");\n/* harmony import */ var _site__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./site */ "./src/site/index.js");\n\n\n\n\n\n\n\n\n// ===========================================================================\nclass BehaviorManager\n{\n  constructor() {\n    this.behaviors = [];\n    this.mainBehavior = null;\n    this.inited = false;\n    (0,_lib_utils__WEBPACK_IMPORTED_MODULE_3__.behavior_log)("Loaded behaviors for: " + self.location.href);\n  }\n\n  init(opts = {autofetch: true, autoplay: true, autoscroll: true, siteSpecific: true}) {\n    if (this.inited) {\n      return;\n    }\n\n    this.inited = true;\n\n    if (!self.window) {\n      return;\n    }\n\n    this.timeout = opts.timeout;\n\n    // default if omitted is \'console.log\'\n    if (opts.log !== undefined) {\n      let logger = opts.log;\n      // if string, look up as global\n      if (typeof(logger) === "string") {\n        logger = self[logger];\n      }\n      // if function, set to it\n      if (typeof(logger) === "function") {\n        (0,_lib_utils__WEBPACK_IMPORTED_MODULE_3__._setLogFunc)(logger);\n      // if false, disable logging\n      } else if (logger === false) {\n        (0,_lib_utils__WEBPACK_IMPORTED_MODULE_3__._setLogFunc)(null);\n      }\n    }\n\n    if (opts.autofetch) {\n      (0,_lib_utils__WEBPACK_IMPORTED_MODULE_3__.behavior_log)("Enable AutoFetcher");\n      this.behaviors.push(new _autofetcher__WEBPACK_IMPORTED_MODULE_0__.AutoFetcher());\n    }\n\n    if (opts.autoplay) {\n      (0,_lib_utils__WEBPACK_IMPORTED_MODULE_3__.behavior_log)("Enable Autoplay");\n      this.behaviors.push(new _autoplay__WEBPACK_IMPORTED_MODULE_1__.Autoplay());\n    }\n\n    let siteMatch = false;\n\n    if (self.window.top !== self.window) {\n      return;\n    }\n\n    if (opts.siteSpecific) {\n      for (const siteBehaviorClass of _site__WEBPACK_IMPORTED_MODULE_4__.default) {\n        if (siteBehaviorClass.isMatch()) {\n          (0,_lib_utils__WEBPACK_IMPORTED_MODULE_3__.behavior_log)("Starting Site-Specific Behavior: " + siteBehaviorClass.name);\n          this.mainBehaviorClass = siteBehaviorClass;\n          this.mainBehavior = new siteBehaviorClass();\n          siteMatch = true;\n          break;\n        }\n      }\n    } \n\n    if (!siteMatch && opts.autoscroll) {\n      (0,_lib_utils__WEBPACK_IMPORTED_MODULE_3__.behavior_log)("Starting Autoscroll");\n      this.mainBehaviorClass = _autoscroll__WEBPACK_IMPORTED_MODULE_2__.AutoScroll;\n      this.mainBehavior = new _autoscroll__WEBPACK_IMPORTED_MODULE_2__.AutoScroll();\n    }\n\n    if (this.mainBehavior)  {\n      this.behaviors.push(this.mainBehavior);\n    }\n  }\n\n  async run(opts) {\n    this.init(opts);\n\n    await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_3__.awaitLoad)();\n\n    if (this.mainBehavior) {\n      this.mainBehavior.start();\n    }\n\n    let allBehaviors = Promise.allSettled(this.behaviors.map(x => x.done()));\n\n    if (this.timeout) {\n      (0,_lib_utils__WEBPACK_IMPORTED_MODULE_3__.behavior_log)(`Waiting for behaviors to finish or ${this.timeout}ms timeout`);\n      allBehaviors = Promise.race([allBehaviors, (0,_lib_utils__WEBPACK_IMPORTED_MODULE_3__.sleep)(this.timeout)]);\n    } else {\n      (0,_lib_utils__WEBPACK_IMPORTED_MODULE_3__.behavior_log)(`Waiting for behaviors to finish`);\n    }\n\n    await allBehaviors;\n    (0,_lib_utils__WEBPACK_IMPORTED_MODULE_3__.behavior_log)("All Behaviors Done!");\n  }\n\n  pause() {\n    (0,_lib_utils__WEBPACK_IMPORTED_MODULE_3__.behavior_log)("Pausing Main Behavior" + this.mainBehaviorClass.name);\n    if (this.mainBehavior) {\n      this.mainBehavior.pause();\n    }\n  }\n\n  unpause() {\n    (0,_lib_utils__WEBPACK_IMPORTED_MODULE_3__.behavior_log)("Unpausing Main Behavior: " + this.mainBehaviorClass.name);\n    if (this.mainBehavior) {\n      this.mainBehavior.unpause();\n    }\n  }\n}\n\nself.__bx_behaviors = new BehaviorManager();\n\n\n//# sourceURL=webpack://browsertrix-behaviors/./src/index.js?')},"./src/lib/utils.js":
/*!**************************!*\
  !*** ./src/lib/utils.js ***!
  \**************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "sleep": () => (/* binding */ sleep),\n/* harmony export */   "waitUntil": () => (/* binding */ waitUntil),\n/* harmony export */   "awaitLoad": () => (/* binding */ awaitLoad),\n/* harmony export */   "behavior_log": () => (/* binding */ behavior_log),\n/* harmony export */   "_setLogFunc": () => (/* binding */ _setLogFunc),\n/* harmony export */   "RestoreState": () => (/* binding */ RestoreState),\n/* harmony export */   "HistoryState": () => (/* binding */ HistoryState),\n/* harmony export */   "xpathNode": () => (/* binding */ xpathNode),\n/* harmony export */   "xpathNodes": () => (/* binding */ xpathNodes),\n/* harmony export */   "xpathString": () => (/* binding */ xpathString),\n/* harmony export */   "Behavior": () => (/* binding */ Behavior)\n/* harmony export */ });\nlet _logFunc = console.log;\n\nfunction sleep(timeout) {\n  return new Promise((resolve) => setTimeout(resolve, timeout));\n}\n\nasync function waitUntil(pred, timeout) {\n  while (!pred()) {\n    await sleep(timeout);\n  }\n}\n\nfunction awaitLoad() {\n  return new Promise((resolve) => {\n    if (document.readyState === "complete") {\n      resolve();\n    } else {\n      window.addEventListener("load", resolve);\n    }\n  });\n}\n\nfunction behavior_log(msg, type = "debug") {\n  if (_logFunc) {\n    _logFunc({msg: JSON.stringify(msg), type});\n  }\n}\n\nfunction _setLogFunc(func) {\n  _logFunc = func;\n}\n\n// ===========================================================================\nclass RestoreState {\n  constructor(childMatchSelect, child) {\n    this.matchValue = xpathString(childMatchSelect, child);\n  }\n\n  async restore(rootPath, childMatch) {\n    let root = null;\n    \n    while (root = xpathNode(rootPath), !root) {\n      await sleep(100);\n    }\n\n    return xpathNode(childMatch.replace("$1", this.matchValue), root);\n  }\n}\n\n// ===========================================================================\nclass HistoryState {\n  constructor(op) {\n    this.loc = window.location.href;\n    op();\n  }\n\n  get changed() {\n    return window.location.href !== this.loc;\n  }\n\n  goBack(backButtonQuery) {\n    if (!this.changed) {\n      return Promise.resolve(true);\n    }\n\n    const backButton = xpathNode(backButtonQuery);\n\n    return new Promise((resolve, reject) => {\n      window.addEventListener(\'popstate\', (event) => {\n      resolve();\n      }, {once: true});\n\n      if (backButton) {\n        backButton.click();\n      } else {\n        window.history.back();\n      }\n    });\n  }\n}\n\n\n// ===========================================================================\nfunction xpathNode(path, root) {\n  root = root || document;\n  return document.evaluate(path, root, null, XPathResult.FIRST_ORDERED_NODE_TYPE).singleNodeValue;\n}\n\nfunction* xpathNodes(path, root) {\n  root = root || document;\n  let iter = document.evaluate(path, root, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);\n  let result = null;\n  while (result = iter.iterateNext()) {\n    yield result;\n  }\n}\n\nfunction xpathString(path, root) {\n  root = root || document;\n  return document.evaluate(path, root, null, XPathResult.STRING_TYPE).stringValue;\n}\n\n\n// ===========================================================================\nclass Behavior\n{\n  constructor() {\n    this._running = null;\n    this.paused = null;\n    this._unpause = null;\n  }\n\n  start() {\n    this._running = this.run();\n  }\n\n  done() {\n    return this._running ? this._running : Promise.resolve();\n  }\n\n  async run() {\n    for await (const step of this) {\n      behavior_log(step, "info");\n      if (this.paused) {\n        await this.paused;\n      }\n    }\n    behavior_log({msg: "done!"}, "info");\n  }\n\n  pause() {\n    if (this.paused) {\n      return;\n    }\n    this.paused = new Promise((resolve) => {\n      this._unpause = resolve;\n    });\n  }\n\n  unpause() {\n    if (this._unpause) {\n      this._unpause();\n      this.paused = null;\n      this._unpause = null;\n    }\n  }\n}\n\n\n//# sourceURL=webpack://browsertrix-behaviors/./src/lib/utils.js?')},"./src/site/index.js":
/*!***************************!*\
  !*** ./src/site/index.js ***!
  \***************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _instagram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instagram */ "./src/site/instagram.js");\n/* harmony import */ var _twitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./twitter */ "./src/site/twitter.js");\n\n\n\nconst siteBehaviors = [\n  _instagram__WEBPACK_IMPORTED_MODULE_0__.InstagramPostsBehavior,\n  _twitter__WEBPACK_IMPORTED_MODULE_1__.TwitterTimelineBehavior\n];\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (siteBehaviors);\n\n//# sourceURL=webpack://browsertrix-behaviors/./src/site/index.js?')},"./src/site/instagram.js":
/*!*******************************!*\
  !*** ./src/site/instagram.js ***!
  \*******************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "InstagramPostsBehavior": () => (/* binding */ InstagramPostsBehavior)\n/* harmony export */ });\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/utils */ "./src/lib/utils.js");\n\n\n\n\n// ===========================================================================\nclass InstagramPostsBehavior extends _lib_utils__WEBPACK_IMPORTED_MODULE_0__.Behavior\n{\n  static isMatch() {\n    return window.location.href.match(/https:\\/\\/(www\\.)?instagram\\.com\\/\\w[\\w]+/);\n  }\n\n  static get name() {\n    return "Instagram";\n  }\n\n  constructor() {\n    super();\n    this.state = {};\n        \n    this.rootPath = "//article/div/div";\n    this.childMatchSelect = "string(.//a[starts-with(@href, \'/\')]/@href)";\n    this.childMatch = "child::div[.//a[@href=\'$1\']]";\n\n    this.firstPostInRow = "div[1]/a";\n    this.postCloseButton = "//button[.//*[@aria-label=\\"Close\\"]]";\n\n    this.nextPost = "//div[@role=\'dialog\']//a[text()=\'Next\']";\n    this.postLoading = "//*[@aria-label=\'Loading...\']";\n\n    this.subpostNextOnlyChevron = "//article[@role=\'presentation\']//div[@role=\'presentation\']/following-sibling::button";\n    this.subpostPrevNextChevron = this.subpostNextOnlyChevron + "[2]";\n\n    this.commentRoot = "//article/div[3]/div[1]/ul";\n\n    this.viewReplies = "li//button[span[contains(text(), \'View replies\')]]";\n    this.loadMore = "//button[span[@aria-label=\'Load more comments\']]";\n\n    this.scrollOpts = {block: "start", inline: "nearest", behavior: "smooth"};\n  }\n\n  async waitForNext(child) {\n    if (!child) {\n      return null;\n    }\n\n    await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.sleep)(100);\n\n    if (!child.nextElementSibling) {\n      return null;\n    }\n\n    //     while (xpathNode(this.progressQuery, child.nextElementSibling)) {\n    //       await sleep(100);\n    //     }\n\n    return child.nextElementSibling;\n  }\n\n  async* iterRow() {\n    let root = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.xpathNode)(this.rootPath);\n\n    if (!root) {\n      return;\n    }\n\n    let child = root.firstElementChild;\n\n    if (!child) {\n      return;\n    }\n\n    while (child) {\n      await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.sleep)(100);\n\n      const restorer = new _lib_utils__WEBPACK_IMPORTED_MODULE_0__.RestoreState(this.childMatchSelect, child);\n\n      if (restorer.matchValue) {\n        yield child;\n\n        child = await restorer.restore(this.rootPath, this.childMatch);\n      }\n\n      child = await this.waitForNext(child);\n    }\n  }\n\n  async viewFirstPost() {\n    let root = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.xpathNode)(this.rootPath);\n\n    if (!root || !root.firstElementChild) {\n      return;\n    }\n\n    const firstPostHref = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.xpathString)(this.childMatchSelect, root.firstElementChild);\n\n    const origLoc = window.location.href;\n\n    window.history.replaceState({}, "", firstPostHref);\n    window.dispatchEvent(new PopStateEvent("popstate", { state: {} }));\n\n    let root2 = null;\n    let root3 = null;\n\n    await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.waitUntil)(() => (root2 = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.xpathNode)(this.rootPath)) !== root && root2, 1000);\n\n    window.history.replaceState({}, "", origLoc);\n    window.dispatchEvent(new PopStateEvent("popstate", { state: {} }));\n\n    await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.waitUntil)(() => (root3 = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.xpathNode)(this.rootPath)) !== root2 && root3, 1000);\n  }\n\n  async *iterSubposts() {\n    let next = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.xpathNode)(this.subpostNextOnlyChevron);\n\n    yield this.state;\n\n    while (next) {\n      next.click();\n      await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.sleep)(1000);\n\n      next = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.xpathNode)(this.subpostPrevNextChevron);\n    }\n\n    await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.sleep)(1000);\n  }\n\n  async iterComments() {\n    const root = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.xpathNode)(this.commentRoot);\n\n    let child = root.firstElementChild;\n\n    while (child) {\n      child.scrollIntoView(this.scrollOpts);\n\n      let viewReplies;\n\n      while ((viewReplies = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.xpathNode)(this.viewReplies, child)) !== null) {\n        viewReplies.click();\n        await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.sleep)(500);\n      }\n\n      if (child.nextElementSibling && child.nextElementSibling.tagName === "LI") {\n        let loadMore = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.xpathNode)(this.loadMore, child.nextElementSibling);\n        if (loadMore) {\n          loadMore.click();\n          await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.sleep)(1000);\n        } \n      }\n\n      child = child.nextElementSibling;\n      await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.sleep)(500);\n    }\n  }\n\n  async* iterPosts(next) {\n    let count = 0;\n    \n    while (next && ++count <= 3) {\n      next.click();\n      await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.sleep)(1000);\n\n      await fetch(window.location.href);\n\n      yield* this.iterSubposts();\n\n      await Promise.race([\n        this.iterComments(),\n        (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.sleep)(20000)\n      ]);\n\n      next = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.xpathNode)(this.nextPost);\n\n      while (!next && (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.xpathNode)(this.postLoading)) {\n        await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.sleep)(500);\n      }\n    }\n\n    await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.sleep)(1000);\n  }\n\n  async* [Symbol.asyncIterator]() {   \n    await this.viewFirstPost();\n    \n    for await (const row of this.iterRow()) {\n      row.scrollIntoView(this.scrollOpts);\n\n      await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.sleep)(500);\n\n      const first = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.xpathNode)(this.firstPostInRow, row);\n\n      yield* this.iterPosts(first);\n\n      const close = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.xpathNode)(this.postCloseButton);\n      if (close) {\n        close.click();\n      }\n\n      await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.sleep)(1000);\n    }\n  }\n}\n\n\n//# sourceURL=webpack://browsertrix-behaviors/./src/site/instagram.js?')},"./src/site/twitter.js":
/*!*****************************!*\
  !*** ./src/site/twitter.js ***!
  \*****************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "TwitterTimelineBehavior": () => (/* binding */ TwitterTimelineBehavior)\n/* harmony export */ });\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/utils */ "./src/lib/utils.js");\n\n\n\n// ===========================================================================\nclass TwitterTimelineBehavior extends _lib_utils__WEBPACK_IMPORTED_MODULE_0__.Behavior\n{\n  static isMatch() {\n    return window.location.href.match(/https:\\/\\/(www\\.)?twitter\\.com\\//);\n  }\n\n  static get name() {\n    return "Twitter";\n  }\n\n  constructor(maxDepth = 1) {\n    super();\n    this.maxDepth = maxDepth || 0;\n\n    this.rootPath = "//div[starts-with(@aria-label, \'Timeline\')]/*[1]";\n    this.anchorQuery = ".//article";\n    this.childMatchSelect = "string(.//article//a[starts-with(@href, \'/\') and @aria-label]/@href)";\n    this.childMatch = "child::div[.//a[@href=\'$1\']]";\n\n    this.expandQuery = ".//div[@role=\'button\' and @aria-haspopup=\'false\']//*[contains(text(), \'more repl\')]";\n    this.quoteQuery = ".//div[@role=\'blockquote\' and @aria-haspopup=\'false\']";\n\n    this.imageQuery = ".//a[@role=\'link\' and starts-with(@href, \'/\') and contains(@href, \'/photo/\')]";\n    this.imageNextQuery = "//div[@aria-label=\'Next slide\']";\n    this.imageCloseQuery = "//div[@aria-label=\'Close\' and @role=\'button\']";\n    this.backButtonQuery = "//div[@aria-label=\'Back\' and @role=\'button\']";\n\n    this.progressQuery = ".//*[@role=\'progressbar\']";\n\n    this.promoted = ".//*[text()=\\"Promoted\\"]";\n\n    this.seenTweets = new Set();\n    this.seenMediaTweets = new Set();\n\n    this.state = {\n      videos: 0,\n      imagePopups: 0,\n      threaded: 0,\n      tweets: 0\n    };\n  }\n\n  getState(msg, incrValue) {\n    if (incrValue && this.state[incrValue] != undefined) {\n      this.state[incrValue]++;\n    }\n\n    return {state: this.state, msg};\n  }\n\n  async waitForNext(child) {\n    if (!child) {\n      return null;\n    }\n\n    await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.sleep)(100);\n\n    if (!child.nextElementSibling) {\n      return null;\n    }\n\n    while ((0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.xpathNode)(this.progressQuery, child.nextElementSibling)) {\n      await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.sleep)(100);\n    }\n\n    return child.nextElementSibling;\n  }\n\n  async expandMore(child) {\n    const expandElem = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.xpathNode)(this.expandQuery, child);\n    if (!expandElem) {\n      return child;\n    }\n\n    const prev = child.previousElementSibling;\n    expandElem.click();\n    await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.sleep)(100);\n    while ((0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.xpathNode)(this.progressQuery, prev.nextElementSibling)) {\n      await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.sleep)(100);\n    }\n    child = prev.nextElementSibling;\n    return child;\n  }\n\n  async* infScroll() {\n    let root = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.xpathNode)(this.rootPath);\n\n    if (!root) {\n      return;\n    }\n\n    let child = root.firstElementChild;\n\n    if (!child) {\n      return;\n    }\n\n    while (child) {\n      let anchorElem = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.xpathNode)(this.anchorQuery, child);\n\n      if (!anchorElem && this.expandQuery) {\n        child = await this.expandMore(child, this.expandQuery, this.progressQuery);\n        anchorElem = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.xpathNode)(this.anchorQuery, child);\n      }\n\n      if (child && child.innerText) {\n        child.scrollIntoView();      \n      }\n\n      if (child && anchorElem) {\n        await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.sleep)(100);\n\n        const restorer = new _lib_utils__WEBPACK_IMPORTED_MODULE_0__.RestoreState(this.childMatchSelect, child);\n\n        if (restorer.matchValue) {\n          yield anchorElem;\n\n          child = await restorer.restore(this.rootPath, this.childMatch);\n        }\n      }\n\n      child = await this.waitForNext(child, this.progressQuery);\n    }\n  }\n\n  async* mediaPlaying(tweet) {\n    const media = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.xpathNode)("(.//video | .//audio)", tweet);\n    if (!media || media.paused) {\n      return;\n    }\n\n    let msg = "Waiting for media playback ";\n\n    try {\n      const mediaTweetUrl = new URL((0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.xpathString)(this.childMatchSelect, tweet.parentElement), window.location.origin).href;\n      if (this.seenMediaTweets.has(mediaTweetUrl)) {\n        return;\n      }\n      msg += "for " + mediaTweetUrl;\n      this.seenMediaTweets.add(mediaTweetUrl);\n    } catch (e) {\n      console.warn(e);\n    }\n\n    msg += "to finish...";\n\n    yield this.getState(msg, "videos");\n\n    const p = new Promise((resolve) => {\n      media.addEventListener("ended", () => resolve());\n      media.addEventListener("abort", () => resolve());\n      media.addEventListener("error", () => resolve());\n      media.addEventListener("pause", () => resolve());\n    });\n\n    await Promise.race([p, (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.sleep)(60000)]);\n  }\n\n  async* iterTimeline(depth = 0) {\n    if (this.seenTweets.has(window.location.href)) {\n      return;\n    }\n\n    yield this.getState("Capturing thread: " + window.location.href);\n\n    // iterate over infinite scroll of tweets\n    for await (const tweet of this.infScroll()) {\n      // skip promoted tweets\n      if ((0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.xpathNode)(this.promoted, tweet)) {\n        continue;\n      }\n\n      await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.sleep)(1000);\n\n      // process images\n      const imagePopup = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.xpathNode)(this.imageQuery, tweet);\n\n      if (imagePopup) {\n        const imageState = new _lib_utils__WEBPACK_IMPORTED_MODULE_0__.HistoryState(() => imagePopup.click());\n\n        yield this.getState("Loading Image: " + window.location.href, "imagePopups");\n\n        await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.sleep)(1000);\n\n        let nextImage = null;\n        let prevLocation = window.location.href;\n\n        while ((nextImage = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.xpathNode)(this.imageNextQuery)) != null) {\n          nextImage.click();\n          await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.sleep)(400);\n\n          if (window.location.href === prevLocation) {\n            await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.sleep)(1000);\n            break;\n          }\n          prevLocation = window.location.href;\n\n          yield this.getState("Loading Image: " + window.location.href, "imagePopups");\n          await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.sleep)(1000);\n        }\n\n\n        await imageState.goBack(this.imageCloseQuery);\n      }\n\n      // process quoted tweet\n      const quoteTweet = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.xpathNode)(this.quoteQuery, tweet);\n\n      if (quoteTweet) {\n        const quoteState = new _lib_utils__WEBPACK_IMPORTED_MODULE_0__.HistoryState(() => quoteTweet.click());\n\n        await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.sleep)(100);\n\n        yield this.getState("Capturing Quote: " + window.location.href);\n\n        if (!this.seenTweets.has(window.location.href) && depth < this.maxDepth) {\n          yield* this.iterTimeline(depth + 1, this.maxDepth);\n          this.seenTweets.add(window.location.href);\n        }\n\n        // wait\n        await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.sleep)(2000);\n\n        await quoteState.goBack(this.backButtonQuery);\n        //tweet = await quoteState.restore(rootPath, childMatch);\n\n        // wait before continuing\n        await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.sleep)(1000);\n      }\n\n      // await any video or audio\n      yield* this.mediaPlaying(tweet);\n\n\n      // track location to see if click goes to new url\n      const tweetState = new _lib_utils__WEBPACK_IMPORTED_MODULE_0__.HistoryState(() => tweet.click());\n\n      await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.sleep)(200);\n\n      if (tweetState.changed) {\n        yield this.getState("Capturing Tweet: " + window.location.href);\n\n        if (!this.seenTweets.has(window.location.href) && depth < this.maxDepth) {\n          yield* this.iterTimeline(depth + 1, this.maxDepth);\n          this.seenTweets.add(window.location.href);\n        }\n\n        // wait\n        await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.sleep)(500);\n\n        await tweetState.goBack(this.backButtonQuery);\n      }\n\n      if (depth === 0) {\n        this.state.tweets++;\n      } else {\n        this.state.threaded++;\n      }\n\n      // wait before continuing\n      await (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.sleep)(1000);\n    }\n  }\n\n  async* [Symbol.asyncIterator]() {\n    yield* this.iterTimeline(0);\n  }\n}\n\n\n//# sourceURL=webpack://browsertrix-behaviors/./src/site/twitter.js?')}},__webpack_module_cache__={};function __webpack_require__(e){if(__webpack_module_cache__[e])return __webpack_module_cache__[e].exports;var n=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](n,n.exports,__webpack_require__),n.exports}__webpack_require__.d=(e,n)=>{for(var t in n)__webpack_require__.o(n,t)&&!__webpack_require__.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},__webpack_require__.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./src/index.js")})();